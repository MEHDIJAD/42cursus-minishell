/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_builtin.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/14 20:46:17 by ymazini           #+#    #+#             */
/*   Updated: 2025/05/17 20:38:14 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../exec_header.h"

static int	handle_export_display(t_cmd *cmd, t_data *data)
{
	int	original_stdin;
	int	original_stdout;
	int	redir_status;
	int	builtin_status;

	if (save_original_fds(&original_stdin, &original_stdout) == -1)
		return (EXIT_FAILURE);
	redir_status = apply_redirections(cmd);
	if (redir_status == 0)
		builtin_status = ft_export(cmd, data);
	else
		data->last_exit_status = EXIT_FAILURE;
	restore_original_fds(original_stdin, original_stdout);
	return (data->last_exit_status);
}

static int	handle_output_builtin(t_cmd *cmd, t_data *data)
{
	int	original_stdin;
	int	original_stdout;
	int	redir_status;
	int	builtin_status;

	builtin_status = -1;
	if (save_original_fds(&original_stdin, &original_stdout) == -1)
		return (EXIT_FAILURE);
	redir_status = apply_redirections(cmd);
	if (redir_status == 0)
	{
		if (ft_strncmp(cmd->argv[0], "pwd", 4) == 0)
			builtin_status = ft_pwd(cmd, data);
		else if (ft_strncmp(cmd->argv[0], "echo", 5) == 0)
			builtin_status = ft_echo(cmd, data);
		else if (ft_strncmp(cmd->argv[0], "env", 4) == 0)
			builtin_status = ft_env(cmd, data);
	}
	else
	{
		data->last_exit_status = EXIT_FAILURE;
		builtin_status = EXIT_FAILURE;
	}
	restore_original_fds(original_stdin, original_stdout);
	return (builtin_status);
}

int	execute_built_ins(t_cmd *cmd, t_data *data)
{
	if (!cmd || !cmd->argv || !cmd->argv[0])
		return (-1);
	if (ft_strncmp(cmd->argv[0], "exit", 5) == 0)
		return (ft_exit(cmd, data));
	if (ft_strncmp(cmd->argv[0], "cd", 3) == 0)
		return (ft_cd(cmd, data));
	if (ft_strncmp(cmd->argv[0], "unset", 6) == 0)
		return (ft_unset(cmd, data));
	if (ft_strncmp(cmd->argv[0], "export", 7) == 0)
	{
		if (cmd->argv[1] == NULL)
			return (handle_export_display(cmd, data));
		else
			return (ft_export(cmd, data));
	}
	if (ft_strncmp(cmd->argv[0], "pwd", 4) == 0
		||ft_strncmp(cmd->argv[0], "echo", 5) == 0
		||ft_strncmp(cmd->argv[0], "env", 4) == 0)
		return (handle_output_builtin(cmd, data));
	return (-1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   executor.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/22 17:30:20 by ymazini           #+#    #+#             */
/*   Updated: 2025/05/25 16:30:03 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../exec_header.h"

static	int	handle_single_command(t_cmd *cmd_node, t_data *data)
{
	data->last_exit_status = 0;
	if (cmd_node->argv && cmd_node->argv[0] && cmd_node->argv[0][0] == '\0')
	{
		data->last_exit_status = 127;
		return (redir_r_emty_cmd_wi_redi(cmd_node, data, TRUE));
	}
	else if ((!cmd_node->argv || !cmd_node->argv[0]) && cmd_node->redir)
		return (redir_r_emty_cmd_wi_redi(cmd_node, data, FALSE),
			data->last_exit_status = 0);
	else if (cmd_node->argv && cmd_node->argv[0] && cmd_node->argv[0][0])
	{
		if (is_parent_builtin(cmd_node))
			execute_built_ins(cmd_node, data);
		else
		{
			execute_external_command(cmd_node, data);
			if (data->last_exit_status == 127
				|| data->last_exit_status == 126 || data->last_exit_status == 2)
				redir_r_emty_cmd_wi_redi(cmd_node, data, FALSE);
		}
	}
	return (data->last_exit_status);
}

int	execute_commands(t_cmd *cmd_list, t_data *data)
{
	int		command_count;
	t_cmd	*counter;

	if (!cmd_list)
		return (data->last_exit_status = 0, 0);
	command_count = 0;
	counter = cmd_list;
	while (counter != NULL)
	{
		command_count++;
		counter = counter->next;
	}
	if (command_count == 1)
	{
		data->print_flag = TRUE;
		return (handle_single_command(cmd_list, data));
	}
	else
		execute_pipeline(cmd_list, data);
	return (data->last_exit_status);
}

static	void	assign_fork(pid_t pid, char *path, t_data *data, t_cmd *cmd)
{
	if (pid < 0)
	{
		perror("minishell: fork");
			free(path);
			path = NULL;
		data->last_exit_status = 1;
		return ;
	}
	else if (pid == 0)
	{
		set_signal_handlers_default();
		execute_child_process(cmd, data, path);
	}
}

int	execute_external_command(t_cmd *cmd, t_data *data)
{
	char	*path;
	pid_t	pid;
	int		status_dual_job;
	int		err;

	if (cmd->argv[0])
	{
		status_dual_job = print_err_exec_cmd(cmd->argv[0], data);
		if (status_dual_job != 77)
			return (status_dual_job);
	}
	errno = 0;
	path = find_command_path(cmd->argv[0], data->env_list);
	err = errno;
	if (!path)
		return (handle_path_error(cmd->argv[0], err, data));
	pid = fork();
	assign_fork(pid, path, data, cmd);
	(free(path), path = NULL);
	waitpid(pid, &status_dual_job, 0);
	update_last_exit_status(data, status_dual_job);
	return (data->last_exit_status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   executor_tools.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/20 17:14:55 by ymazini           #+#    #+#             */
/*   Updated: 2025/05/23 16:24:14 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../exec_header.h"

int	handle_empty_command_string_error1(t_data *data, char *cmd_name_for_error)
{
	ft_putstr_fd("minishell: ", STDERR_FILENO);
	if (cmd_name_for_error && cmd_name_for_error[0] == '\0')
		ft_putstr_fd(": command not found\n", STDERR_FILENO);
	else if (cmd_name_for_error)
	{
		ft_putstr_fd(cmd_name_for_error, STDERR_FILENO);
		ft_putstr_fd(": command not found\n", STDERR_FILENO);
	}
	else
		ft_putstr_fd("command not found\n", STDERR_FILENO);
	data->last_exit_status = 127;
	return (127);
}

int	print_err_exec_cmd(char *cmd, t_data *data)
{
	if (ft_strncmp(cmd, ".", 2) == 0)
	{
		ft_putstr_fd("minishell: .: filename argument required\n", 2);
		ft_putstr_fd(".: usage: . filename [arguments]\n", 2);
		return (data->last_exit_status = 2, 2);
	}
	if (ft_strncmp(cmd, "..", 3) == 0)
	{
		ft_putstr_fd("minishell: ..: command not found\n", 2);
		return (data->last_exit_status = 127, 127);
	}
	return (77);
}

int	handle_path_error(char *name, int err, t_data *data)
{
	ft_putstr_fd("minishell: ", STDERR_FILENO);
	ft_putstr_fd(name, STDERR_FILENO);
	if (err == EISDIR)
	{
		ft_putstr_fd(": is a directory\n", STDERR_FILENO);
		return (data->last_exit_status = 126, 126);
	}
	else if (err == EACCES)
	{
		ft_putstr_fd(": Permission denied\n", STDERR_FILENO);
		return (data->last_exit_status = 126, 126);
	}
	else
	{
		ft_putstr_fd(": command not found\n", STDERR_FILENO);
		return (data->last_exit_status = 127, 127);
	}
}

int	redir_r_emty_cmd_wi_redi(t_cmd *cmd, t_data *data, int is_empty)
{
	pid_t	child;
	int		status;

	if (cmd && cmd->argv && cmd->argv[0] && cmd->redir
		&& (cmd->redir->type == TOKEN_REDIR_IN
			|| cmd->redir->type == TOKEN_REDIR_HEREDOC))
		return (0);
	child = fork();
	if (child < 0)
		return (perror("minishell: fork for redir"),
			data->last_exit_status = 1, 1);
	if (child == 0)
	{
		set_signal_handlers_default();
		if (apply_redirections(cmd) != 0)
			exit(EXIT_FAILURE);
		if (is_empty)
			handle_empty_command_string_error1(data, cmd->argv[0]);
		exit(data->last_exit_status);
	}
	waitpid(child, &status, 0);
	if (cmd && !cmd->argv && cmd->redir)
		update_last_exit_status(data, status);
	return (data->last_exit_status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   executor_utils.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/04 16:28:42 by ymazini           #+#    #+#             */
/*   Updated: 2025/05/25 16:10:32 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../exec_header.h"

void	handle_path_error_and_exit(char *cmd_name, char **envp_array,
									int original_errno)
{
	ft_putstr_fd("minishell: ", STDERR_FILENO);
	ft_putstr_fd(cmd_name, STDERR_FILENO);
	if (original_errno == EISDIR)
	{
		ft_putstr_fd(": is a directory\n", STDERR_FILENO);
		free_arr(envp_array);
		exit(126);
	}
	else if (original_errno == EACCES)
	{
		ft_putstr_fd(": Permission denied\n", STDERR_FILENO);
		free_arr(envp_array);
		exit(126);
	}
	else
	{
		ft_putstr_fd(": command not found\n", STDERR_FILENO);
		free_arr(envp_array);
		exit(127);
	}
}

void	execute_child_process(t_cmd *cmd, t_data *data, char *path)
{
	char	**envp_array;

	if (apply_redirections(cmd) != 0)
	{
		(free(path), path = NULL);
		exit(EXIT_FAILURE);
	}
	envp_array = convert_envlist_to_array(data->env_list);
	if (!envp_array)
	{
		ft_putstr_fd("minishell: child: env setup failed\n", STDERR_FILENO);
		(free(path), path = NULL);
		exit(EXIT_FAILURE);
	}
	execve(path, cmd->argv, envp_array);
	ft_putstr_fd("minishell2: ", STDERR_FILENO);
	perror(cmd->argv[0]);
	(free(path), path = NULL);
	free_arr(envp_array);
	exit(126);
}

static int	try_builtins(t_cmd *cmd, t_data *data)
{
	int	status;

	status = execute_built_ins(cmd, data);
	if (status != -1)
		exit(status);
	return (-1);
}

static void	run_external(t_cmd *cmd, t_data *data)
{
	char	*path;
	char	**envp;
	int		errno_saved;

	envp = convert_envlist_to_array(data->env_list);
	if (!envp)
		exit(EXIT_FAILURE);
	errno = 0;
	path = find_command_path(cmd->argv[0], data->env_list);
	errno_saved = errno;
	if (!path)
		handle_path_error_and_exit(cmd->argv[0], envp, errno_saved);
	execve(path, cmd->argv, envp);
	ft_putstr_fd("minishell: ", STDERR_FILENO);
	perror(cmd->argv[0]);
	(free(path), path = NULL);
	free_arr(envp);
	envp = NULL;
	exit(126);
}

void	execute_command_node(t_cmd *cmd, t_data *data)
{
	set_signal_handlers_default();
	if (apply_redirections(cmd) != 0)
		exit(EXIT_FAILURE);
	if (!cmd->argv || !cmd->argv[0] || cmd->argv[0][0] == '\0')
	{
		if (!cmd->argv || !cmd->argv[0])
			exit(EXIT_SUCCESS);
	}
	if (cmd->argv[0])
	{
		if (ft_strncmp(cmd->argv[0], ".", 2) == 0)
		{
			ft_putstr_fd("minishell: .: filename argument required\n", 2);
			exit(2);
		}
		if (ft_strncmp(cmd->argv[0], "..", 3) == 0)
		{
			ft_putstr_fd("minishell: ..: command not found\n", STDERR_FILENO);
			exit(127);
		}
	}
	if (try_builtins(cmd, data) >= 0)
		return ;
	run_external(cmd, data);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipeline.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/23 21:01:41 by ymazini           #+#    #+#             */
/*   Updated: 2025/05/25 16:04:20 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../exec_header.h"

static void	parent_pipe_handler(int *prev_pipe_read_end, int pipe_fd[2],
								t_cmd *current_cmd)
{
	if (*prev_pipe_read_end != STDIN_FILENO)
		close(*prev_pipe_read_end);
	if (current_cmd->next != NULL)
	{
		close(pipe_fd[1]);
		*prev_pipe_read_end = pipe_fd[0];
	}
}

static	pid_t	fork_and_exec_child(t_cmd *cmd, t_data *data, int prev_read_end,
										int pipe_fd[2])
{
	pid_t		pid;

	pid = fork();
	if (pid < 0)
		return (perror("fork"), -1);
	else if (pid == 0)
	{
		setup_child_pipes(prev_read_end, pipe_fd, cmd);
		execute_command_node(cmd, data);
	}
	return (pid);
}

static int	handle_pipe_fork_errors(t_cmd *cmd, int prev_fd, int pipe_fd[2])
{
	if (prev_fd != STDIN_FILENO)
		close(prev_fd);
	if (cmd->next)
	{
		close(pipe_fd[0]);
		close(pipe_fd[1]);
	}
	perror("minishell: fork");
	return (EXIT_FAILURE);
}

static int	pipeline_loop(t_cmd *cmd_list, t_data *data, t_pipeline_ctx *ctx)
{
	pid_t	pid;

	while (cmd_list)
	{
		if (cmd_list->next && pipe(ctx->pipe_fd) == -1)
		{
			if (ctx->prev_read != STDIN_FILENO)
				close(ctx->prev_read);
			perror("pipe");
			return (EXIT_FAILURE);
		}
		pid = fork_and_exec_child(cmd_list, data, ctx->prev_read, ctx->pipe_fd);
		if (pid < 0)
			return (handle_pipe_fork_errors(cmd_list,
					ctx->prev_read, ctx->pipe_fd));
		ctx->last_pid = pid;
		parent_pipe_handler(&ctx->prev_read, ctx->pipe_fd, cmd_list);
		cmd_list = cmd_list->next;
	}
	return (EXIT_SUCCESS);
}

int	execute_pipeline(t_cmd *cmd_list, t_data *data)
{
	t_pipeline_ctx	ctx;
	int				cmd_count;
	int				rc;

	ctx.prev_read = STDIN_FILENO;
	ctx.last_pid = -1;
	ctx.pipe_fd[0] = -1;
	ctx.pipe_fd[1] = -1;
	cmd_count = count_commands(cmd_list, data);
	if (cmd_count == 0)
		return (EXIT_SUCCESS);
	rc = pipeline_loop(cmd_list, data, &ctx);
	if (ctx.prev_read != STDIN_FILENO)
		close(ctx.prev_read);
	if (rc != EXIT_SUCCESS)
	{
		data->last_exit_status = rc;
		return (rc);
	}
	return (wait_for_pipeline(cmd_count, ctx.last_pid, data));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipeline_utils.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/04 18:05:52 by ymazini           #+#    #+#             */
/*   Updated: 2025/05/23 23:04:14 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../exec_header.h"

void	setup_child_pipes(int prev_pipe_read, int pipe_fd[2], t_cmd *cmd)
{
	if (prev_pipe_read != STDIN_FILENO)
	{
		if (dup2(prev_pipe_read, STDIN_FILENO) < 0)
			exit(EXIT_FAILURE);
		close(prev_pipe_read);
	}
	if (cmd->next != NULL)
	{
		close(pipe_fd[0]);
		if (dup2(pipe_fd[1], STDOUT_FILENO) < 0)
			exit(EXIT_FAILURE);
		close(pipe_fd[1]);
	}
}

static	void	ft_assign_vars_2_wait(int *flag,
		int *childs_wait_for, int *last_status)
{
	*flag = false;
	*childs_wait_for = -1;
	*last_status = EXIT_SUCCESS;
}

static int	handle_wait_errno(t_data *data)
{
	if (errno == ECHILD)
		return (0);
	perror("minishell: waitpid error");
	data->last_exit_status = EXIT_FAILURE;
	return (EXIT_FAILURE);
}

static void	prnit_nwln(int flag, t_data *data)
{
	if (flag && data->last_exit_status != 130)
		write(STDOUT_FILENO, "\n", 1);
}

int	wait_for_pipeline(int count, pid_t last_pid, t_data *data)
{
	int		wait_status;
	pid_t	finished_pid;
	int		childs_wait_for;
	int		last_status;
	int		flag;

	ft_assign_vars_2_wait(&flag, & childs_wait_for, &last_status);
	while (++childs_wait_for < count)
	{
		finished_pid = waitpid(-1, &wait_status, 0);
		if (finished_pid < 0)
		{
			if (handle_wait_errno(data) == EXIT_FAILURE)
				return (EXIT_FAILURE);
			return (last_status);
		}
		if (WIFSIGNALED(wait_status) && WTERMSIG(wait_status) == SIGINT)
			flag = true;
		if (finished_pid == last_pid)
		{
			update_last_exit_status(data, wait_status);
			last_status = data->last_exit_status;
		}
	}
	return (prnit_nwln(flag, data), flag = false, last_status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipeline_utils2.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/20 18:38:35 by ymazini           #+#    #+#             */
/*   Updated: 2025/05/20 18:49:06 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../exec_header.h"

int	count_commands(t_cmd *cmd_list, t_data *data)
{
	int		count;
	t_cmd	*counter;

	count = 0;
	counter = cmd_list;
	while (counter)
	{
		count++;
		counter = counter->next;
	}
	if (count > 1)
	{
		data->print_flag = FALSE;
	}
	return (count);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   find_path.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazinistudent.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/22 16:41:51 by ymazini           #+#    #+#             */
/*   Updated: 2025/04/22 16:49:18 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../exec_header.h"

int	is_executable(const char *path)
{
	struct stat	statbuf;

	if (stat(path, &statbuf) == -1)
		return (0);
	if (S_ISDIR(statbuf.st_mode))
	{
		errno = EISDIR;
		return (0);
	}
	if (access(path, X_OK) == 0)
		return (1);
	else
	{
		errno = EACCES;
		return (0);
	}
}

static char	**get_and_split_path(t_env *env_list)
{
	char	*path_var_value;
	char	**path_dirs;

	path_var_value = ft_list_getenv(env_list, "PATH");
	if (!path_var_value || path_var_value[0] == '\0')
	{
		return (NULL);
	}
	path_dirs = ft_split(path_var_value, ':');
	if (!path_dirs)
	{
		perror("minishell: ft_split failed for PATH");
		return (NULL);
	}
	return (path_dirs);
}

static char	*check_path_entry(const char *dir, const char *command_name)
{
	char	*temp_slash;
	char	*full_path;

	temp_slash = ft_strjoin(dir, "/");
	if (!temp_slash)
	{
		perror("minishell: ft_strjoin failed");
		return (NULL);
	}
	full_path = ft_strjoin(temp_slash, command_name);
	((free(temp_slash), temp_slash = NULL));
	if (!full_path)
	{
		perror("minishell: ft_strjoin failed");
		return (NULL);
	}
	if (is_executable(full_path))
		return (full_path);
	(free(full_path), full_path = NULL);
	return (NULL);
}

char	*search_path_variable(const char *command_name, t_env *env_list)
{
	char	**path_dirs;
	char	*found_path;
	int		i;

	path_dirs = get_and_split_path(env_list);
	if (!path_dirs)
		return (NULL);
	i = 0;
	found_path = NULL;
	while (path_dirs[i] != NULL)
	{
		found_path = check_path_entry(path_dirs[i], command_name);
		if (found_path)
			break ;
		i++;
	}
	free_arr(path_dirs);
	return (found_path);
}

char	*find_command_path(const char *command_name, t_env *env_list)
{
	if (!command_name || command_name[0] == '\0')
		return (NULL);
	if (ft_strchr(command_name, '/') != NULL)
	{
		if (is_executable(command_name))
			return (ft_strdup(command_name));
		else
			return (NULL);
	}
	else
		return (search_path_variable(command_name, env_list));
}
