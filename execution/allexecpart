
READLINE_LIB_DIR = $(shell brew --prefix readline)/lib
READLINE_INC_DIR = $(shell brew --prefix readline)/include

NAME = minishell_exec_test
CC = cc
#CFLAGS = -Wall -Wextra -Werror -fsanitize=address -g3
CFLAGS = -fsanitize=address -g3

INCLUDES = -I. -I$(LIBFT_DIR)
INCLUDES += -I$(READLINE_INC_DIR)

LDFLAGS = -L$(LIBFT_DIR)
LDFLAGS += -L$(READLINE_LIB_DIR)

LIBS = -lft -lreadline

RM = rm -f

LIBFT_DIR = libft
BUILTIN_DIR = built_in
EXEC_DIR = execution_part

SRCS = main.c $(BUILTIN_DIR)/echo_built_in.c $(BUILTIN_DIR)/cd_built_in.c  $(BUILTIN_DIR)/env_built_in.c    $(BUILTIN_DIR)/exit_built_in.c    $(BUILTIN_DIR)/export_built_in.c    $(BUILTIN_DIR)/unset_built_in.c   $(BUILTIN_DIR)/pwd_built_in.c $(EXEC_DIR)/tools1.c $(EXEC_DIR)/tools2.c $(EXEC_DIR)/tools3.c $(EXEC_DIR)/tools4.c $(EXEC_DIR)/tools5.c $(EXEC_DIR)/execute_builtin.c

OBJS = $(SRCS:.c=.o)

LIBFT_A = $(LIBFT_DIR)/libft.a

all: $(NAME)

$(NAME): $(OBJS) $(LIBFT_A)
	$(CC) $(CFLAGS) $(OBJS) $(LDFLAGS) $(LIBS) -o $(NAME)

$(LIBFT_A):
	@make -C $(LIBFT_DIR)

%.o: %.c exec_header.h Makefile
	$(CC) $(CFLAGS) $(INCLUDES) -c $< -o $@

clean:
	@$(RM) $(OBJS)
	@make -C $(LIBFT_DIR) clean

fclean: clean
	@$(RM) $(NAME)
	@make -C $(LIBFT_DIR) fclean

re: fclean all

.PHONY: all clean fclean re sanitize/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_header.h                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/14 20:26:54 by ymazini           #+#    #+#             */
/*   Updated: 2025/04/16 14:16:14 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef EXEC_HEADER_H
# define EXEC_HEADER_H

# include <stdio.h>
# include <stdlib.h>
# include <unistd.h>
# include <string.h>
# include <sys/wait.h>
# include <fcntl.h>
# include <limits.h>
# include "libft/libft.h"
# include <readline/readline.h>
# include <readline/history.h>

# define TRUE 1
# define FALSE 0

typedef struct t_cmd
{
	char	**arguments;// 
}	t_cmd;

typedef struct s_data
{
	char	**envp;
	int		last_exit_status;
}	t_data;

int		execute_built_ins(t_cmd *test_cmd, t_data *data);
int		ft_pwd(t_data *data);
int		ft_echo(t_data *data, t_cmd *cmd);
int		ft_exit(t_cmd *cmd, t_data *data);
int		ft_env(t_data *data);
int		ft_cd(t_cmd *cmd, t_data *data);
int		ft_export(t_data *data, t_cmd *cmd);
int		ft_unset(t_data *data, t_cmd *cmd);
int		ft_is_only_whitespace(char *str);
void	free_arr(char **arr);
int ft_valid_number(char *s);

#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/14 20:45:09 by ymazini           #+#    #+#             */
/*   Updated: 2025/04/16 15:57:04 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "exec_header.h"

int main(int ac, char **av, char **env)
{
	(void)ac;
	(void)av;
	t_data data; 
	data.envp = env;
	data.last_exit_status = EXIT_SUCCESS;
	char *line = NULL;
	char **args = NULL;
	int status;
	while(TRUE)
	{
		line = readline(">testing built_in:");
		if (!line)
		{
			printf("exit\n");
			break;
		}	
		if (line[0])
			add_history(line);
		args = ft_split(line,' ');
		if (!args)
		{
			perror("ft_split failed:");
			data.last_exit_status = EXIT_FAILURE;
			free(line);
			continue; 
		}	
		if (args[0])
		{
			t_cmd test_cmd;
			test_cmd.arguments = args;
			status = execute_built_ins( &test_cmd , &data);
			if (status != -1 )
				printf("\nbuilt_in was executed with %d\n", data.last_exit_status);
			else
			{
				printf("minishell test: command not found: %s\n", args[0]);
				data.last_exit_status = 127;
			}
		}
		else
			data.last_exit_status = EXIT_SUCCESS;
		free_arr(args);	
		args = NULL;
		free(line);
		line = NULL;
	}
	return (data.last_exit_status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   echo_built_in.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/14 20:46:19 by ymazini           #+#    #+#             */
/*   Updated: 2025/04/15 22:31:03 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../exec_header.h"

static	int	ft_check_n_flag(char *s)
{
	int	i;

	i = 0;
	if (s && s[0] == '-' && s[1] == 'n')
	{
		i = 2;
		while (s[i] == 'n')
			i++;
		return (s[i] == '\0');
	}
	return (0);
}

int	get_printing_start_index(t_cmd *cmd)
{
	int	i;

	i = 1;
	while (cmd->arguments[i])
	{
		if (ft_is_only_whitespace(cmd->arguments[i])
			|| ft_check_n_flag(cmd->arguments[i]))
			i++;
		else
			break ;
	}
	if (cmd->arguments[i] == NULL)
		return (i);
	return (i);
}

void	prepare_echo(t_cmd *cmd, int *print_newline_flag, int *start_index)
{
	int	i;

	i = 1;
	*print_newline_flag = TRUE;
	while (cmd->arguments[i])
	{
		if (ft_check_n_flag(cmd->arguments[i])
			|| ft_is_only_whitespace(cmd->arguments[i]))
		{
			if (ft_check_n_flag(cmd->arguments[i]))
				*print_newline_flag = FALSE;
			i++;
		}
		else
			break ;
	}
	*start_index = get_printing_start_index(cmd);
}

int	ft_echo(t_data *data, t_cmd *cmd)
{
	int	flag_print_newline;
	int	start_index;
	int	i;

	if (!cmd || !cmd->arguments || !cmd->arguments[0])
	{
		ft_putchar_fd('\n', STDOUT_FILENO);
		data->last_exit_status = EXIT_SUCCESS;
		return (EXIT_SUCCESS);
	}
	prepare_echo(cmd, &flag_print_newline, &start_index);
	i = start_index;
	while (cmd->arguments[i])
	{
		ft_putstr_fd(cmd->arguments[i], STDOUT_FILENO);
		if (cmd->arguments[i + 1] != NULL)
			ft_putchar_fd(' ', STDOUT_FILENO);
		i++;
	}
	if (flag_print_newline == TRUE)
		ft_putchar_fd('\n', STDOUT_FILENO);
	data->last_exit_status = EXIT_SUCCESS;
	return (EXIT_SUCCESS);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exit_built_in.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/15 16:06:22 by ymazini           #+#    #+#             */
/*   Updated: 2025/04/16 16:19:54 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../exec_header.h"

int	ft_handle_exit_too_many_args(t_data *data)
{
	ft_putstr_fd("minishell: exit: too many arguments\n", STDERR_FILENO);
	data->last_exit_status = 1;
	return (1);
}

void	ft_handle_exit_numeric_error(t_cmd *cmd, t_data *data)
{
	ft_putstr_fd("minishell: exit: ", STDERR_FILENO);
	if (cmd->arguments[1])
		ft_putstr_fd(cmd->arguments[1], STDERR_FILENO);
	ft_putstr_fd(": numeric argument required\n", STDERR_FILENO);
	// TODO: cleanup before exit
	exit(255);
}
int	ft_exit(t_cmd *cmd, t_data *data)
{
	int				argc;
	int				exit_code_arg;
	unsigned char	exit_status;

	ft_putstr_fd("exit\n", STDERR_FILENO);
	argc = 0;
	while (cmd->arguments[argc])
		argc++;
	if (argc == 1)
	{
		exit_status = (unsigned char)data->last_exit_status;
		// TODO: cleanup
		exit(exit_status);
	}
	if (argc == 2)
	{
		if (ft_valid_number(cmd->arguments[1]))
		{
			exit_code_arg = ft_atoi(cmd->arguments[1]);
			exit_status = (unsigned char)exit_code_arg;
			// TODO: cleanup
			exit(exit_status);
		}
		else
		{
			// TODO: cleanup
			ft_handle_exit_numeric_error(cmd, data);
			return (255);
		}
	}
	else
		return (ft_handle_exit_too_many_args(data));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pwd_built_in.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/15 15:10:19 by ymazini           #+#    #+#             */
/*   Updated: 2025/04/15 22:04:05 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../exec_header.h"

int	ft_pwd(t_data *data)
{
	char	*pwd;

	pwd = NULL;
	pwd = getcwd(NULL, 0);
	if (!pwd)
	{
		perror("getcwd function failed: ");
		data->last_exit_status = EXIT_FAILURE;
		return (free(pwd), pwd = NULL, EXIT_FAILURE);
	}
	ft_putstr_fd(pwd, STDOUT_FILENO);
	ft_putstr_fd("\n", STDOUT_FILENO);
	free(pwd);
	pwd = NULL;
	data->last_exit_status = EXIT_SUCCESS;
	return (EXIT_SUCCESS);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tools1.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/14 22:08:59 by ymazini           #+#    #+#             */
/*   Updated: 2025/04/16 16:12:31 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../exec_header.h"

void	free_arr(char **arr)
{
	int	i;

	i = 0;
	if (!arr)
		return ;
	while (arr[i])
	{
		free(arr[i]);
		i++;
	}
	free(arr);
}

int	ft_is_only_whitespace(char *arg)
{
	int i = 0;
	if (!arg || arg[0] == '\0')
		return (0);
	while (arg[i] == ' ' || (arg[i] >= '\t' && '\r' >= arg[i]))
		i++;
	return (arg[i] == '\0');
}

int	ft_valid_number(char *s)
{
	int	i;

	i = 0;
	if (!s || !s[i])
		return (0);
	if (s[i] == '-' || s[i] == '+')
	{
		i++;
		if (!s[i])
			return (0);
	}
	while (s[i])
	{
		if (!ft_isdigit(s[i]))
			return (0);
		i++;
	}
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_builtin.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/14 20:46:17 by ymazini           #+#    #+#             */
/*   Updated: 2025/04/16 15:33:33 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../exec_header.h"

int	execute_built_ins(t_cmd *test_cmd, t_data *data)
{
	if (!test_cmd || !test_cmd->arguments[0] || !test_cmd->arguments)
		return (-1);
	if (ft_strncmp(test_cmd->arguments[0], "pwd", 4) == 0)
		return (ft_pwd(data));
	if (ft_strncmp(test_cmd->arguments[0], "echo", 5) == 0)
		return (ft_echo(data, test_cmd));
	if (ft_strncmp(test_cmd->arguments[0], "exit", 5) == 0)
		return (ft_exit(test_cmd, data)); 
	// if (ft_strncmp(test_cmd->arguments[0], "env", 3) == 0)
	// 	return ft_env(data);
	// if (ft_strncmp(test_cmd->arguments[0], "cd", 2) == 0)
	// 	return ft_cd(data, test_cmd); 
	// if (ft_strncmp(test_cmd->arguments[0], "export", 6) == 0)
	// 	return ft_export(data, test_cmd); 
	// if (ft_strncmp(test_cmd->arguments[0], "unset", 5) == 0)
	// 	return ft_unset(data, test_cmd);  
	else
		return (-1);
}
