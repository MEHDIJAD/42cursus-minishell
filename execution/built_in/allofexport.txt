/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export_built_in.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/15 16:06:26 by ymazini           #+#    #+#             */
/*   Updated: 2025/05/14 22:43:04 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../exec_header.h"

// static int	validate_and_set_env(char *key,
// 	char *value, char *arg, t_data *data)
// {
// 	if (!ft_is_valid_identifier(key))
// 	{
// 		ft_putstr_fd("minishell: export: `", STDERR_FILENO);
// 		ft_putstr_fd(arg, STDERR_FILENO);
// 		ft_putstr_fd("': not a valid identifier\n", STDERR_FILENO);
// 		return (EXIT_FAILURE);
// 	}
// 	if (ft_list_setenv(&data->env_list, key, value) == -1)
// 	{
// 		perror("minishell: export: setenv error");
// 		return (EXIT_FAILURE);
// 	}
// 	return (EXIT_SUCCESS);
// }

// static int	process_export_pair(char *arg, t_data *data)
// {
// 	char	*equals_ptr;
// 	char	*key;
// 	char	*value;
// 	int		result;

// 	equals_ptr = ft_strchr(arg, '=');
// 	key = NULL;
// 	value = NULL;
// 	result = EXIT_SUCCESS;
// 	if (equals_ptr != NULL)
// 	{
// 		key = ft_substr(arg, 0, equals_ptr - arg);
// 		value = ft_strdup(equals_ptr + 1);
// 		if (!key || !value)
// 			return (free(key), free(value), EXIT_FAILURE);
// 	}
// 	else
// 	{
// 		key = ft_strdup(arg);
// 		if (!key)
// 			return (perror("minishell: export: malloc error"), EXIT_FAILURE);
// 		value = NULL;
// 	}
// 	result = validate_and_set_env(key, value, arg, data);
// 	return (free(key), free(value), result);
// }

// int	ft_export(t_cmd *cmd, t_data *data)
// {
// 	int		i;
// 	int		return_status;

// 	return_status = EXIT_SUCCESS;
// 	if (cmd->argv[1] == NULL)
// 	{
// 		print_export_env(data->env_list);
// 		data->last_exit_status = EXIT_SUCCESS;
// 		return (EXIT_SUCCESS);
// 	}
// 	i = 1;
// 	while (cmd->argv[i] != NULL)
// 	{
// 		if (process_export_pair(cmd->argv[i], data) == EXIT_FAILURE)
// 			return_status = EXIT_FAILURE;
// 		i++;
// 	}
// 	data->last_exit_status = return_status;
// 	return (return_status);
// }



static int	validate_and_set_or_append_env(char *key, char *value_to_set_or_append,
										char *original_arg, t_data *data, int append_mode)
{
	char	*current_value;
	char	*new_value_for_setenv;

	if (!ft_is_valid_identifier(key))
	{
		ft_putstr_fd("minishell: export: `", STDERR_FILENO);
		ft_putstr_fd(original_arg, STDERR_FILENO); // Print original arg for error
		ft_putstr_fd("': not a valid identifier\n", STDERR_FILENO);
		return (EXIT_FAILURE);
	}

	new_value_for_setenv = NULL;
	if (append_mode)
	{
		current_value = ft_list_getenv(data->env_list, key); // Get current value
		if (current_value) // If var exists and has a value, append
		{
			new_value_for_setenv = ft_strjoin(current_value, value_to_set_or_append);
		}
		else // Var doesn't exist or has no value, treat as normal set
		{
			new_value_for_setenv = ft_strdup(value_to_set_or_append);
		}
		if (!new_value_for_setenv)
		{
			perror("minishell: export (append): malloc error");
			return (EXIT_FAILURE);
		}
	}
	else // Not append mode (normal set or set without value)
	{
		if (value_to_set_or_append) // If a value is provided for set
			new_value_for_setenv = ft_strdup(value_to_set_or_append);
		// If value_to_set_or_append is NULL (e.g. export VAR), new_value_for_setenv remains NULL
	}

	// Call ft_list_setenv with the (potentially new or appended) value
	if (ft_list_setenv(&data->env_list, key, new_value_for_setenv) == -1)
	{
		perror("minishell: export: setenv error");
		free(new_value_for_setenv); // Free if allocated
		return (EXIT_FAILURE);
	}

	free(new_value_for_setenv); // Free the strduped/strjoined string for setenv
	return (EXIT_SUCCESS);
}

// Modified process_export_pair to detect and handle "+="
static int	process_export_pair(char *arg, t_data *data)
{
	char	*equals_ptr;
	char	*key;
	char	*value_to_assign;
	int		result;
	int		append_mode;
	size_t	key_len;

	equals_ptr = ft_strchr(arg, '=');
	key = NULL;
	value_to_assign = NULL;
	result = EXIT_SUCCESS;
	append_mode = FALSE;

	if (equals_ptr != NULL) // Argument contains "="
	{
		key_len = equals_ptr - arg;
		// Check if the character before '=' is '+'
		if (key_len > 0 && arg[key_len - 1] == '+')
		{
			append_mode = TRUE;
			key = ft_substr(arg, 0, key_len - 1); // Key is before "+="
		}
		else // Normal assignment "KEY=VALUE"
		{
			key = ft_substr(arg, 0, key_len);
		}
		value_to_assign = ft_strdup(equals_ptr + 1); // Value is after "="
		if (!key || !value_to_assign) // Check malloc results
		{
			perror("minishell: export: malloc error");
			result = EXIT_FAILURE;
		}
	}
	else // No '=' in argument, e.g., "export VAR"
	{
		key = ft_strdup(arg);
		if (!key)
		{
			perror("minishell: export: malloc error");
			result = EXIT_FAILURE;
		}
		// value_to_assign remains NULL
	}

	if (result == EXIT_SUCCESS) // If key/value extraction was okay
	{
		result = validate_and_set_or_append_env(key, value_to_assign, arg, data, append_mode);
	}

	free(key);
	free(value_to_assign); // free(NULL) is safe
	return (result);
}

// Main export function (No changes needed here, logic moved to helpers)
int	ft_export(t_cmd *cmd, t_data *data)
{
	int		i;
	int		return_status;

	return_status = EXIT_SUCCESS;
	if (cmd->argv[1] == NULL) // No arguments, print exported vars
	{
		// Assuming print_export_env is defined elsewhere and handles status
		print_export_env(data->env_list);
		data->last_exit_status = EXIT_SUCCESS;
		return (EXIT_SUCCESS);
	}

	// Process arguments
	i = 1;
	while (cmd->argv[i] != NULL)
	{
		if (process_export_pair(cmd->argv[i], data) == EXIT_FAILURE)
			return_status = EXIT_FAILURE; // If any arg fails, overall status is failure
		i++;
	}
	data->last_exit_status = return_status;
	return (return_status);
}

    
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export_built_in_utils.c                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/04 14:21:36 by ymazini           #+#    #+#             */
/*   Updated: 2025/05/04 15:08:41 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../exec_header.h"

static void	ft_assign_var(int *count, int *i)
{
	*count = 0;
	*i = -1;
}

void	ft_sort_array(char **array)
{
	int		i;
	int		j;
	int		count;
	char	*temp;

	ft_assign_var(&count, &i);
	if (!array)
		return ;
	while (array[count])
		count++;
	if (count < 2)
		return ;
	while (++i < count - 1)
	{
		j = -1;
		while (++j < count - i - 1)
		{
			if (ft_strncmp(array[j], array[j + 1], -1) > 0)
			{
				temp = array[j];
				array[j] = array[j + 1];
				array[j + 1] = temp;
			}
		}
	}
}

static void	print_single_export_entry(char *env_entry)
{
	char	*equals_ptr;

	ft_putstr_fd("declare -x ", STDOUT_FILENO);
	equals_ptr = ft_strchr(env_entry, '=');
	if (equals_ptr)
	{
		write(STDOUT_FILENO, env_entry, equals_ptr - env_entry + 1);
		ft_putchar_fd('"', STDOUT_FILENO);
		ft_putstr_fd(equals_ptr + 1, STDOUT_FILENO);
		ft_putstr_fd("\"\n", STDOUT_FILENO);
	}
	else
	{
		ft_putstr_fd(env_entry, STDOUT_FILENO);
		ft_putchar_fd('\n', STDOUT_FILENO);
	}
}

void	print_export_env(t_env *env_list)
{
	char	**env_array;
	int		i;
	int		status;

	status = EXIT_SUCCESS;
	env_array = ft_list_to_array(env_list);
	if (!env_array)
	{
		perror("minishell: export: malloc error");
		return ;
	}
	ft_sort_array(env_array);
	i = 0;
	while (env_array[i] != NULL)
	{
		print_single_export_entry(env_array[i]);
		i++;
	}
	free_arr(env_array);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export_built_in_utils2.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/04 14:26:53 by ymazini           #+#    #+#             */
/*   Updated: 2025/05/09 16:47:53 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../exec_header.h"

// static int	count_env_nodes(t_env *env_list)
// {
// 	int		count;
// 	t_env	*curr;

// 	count = 0;
// 	curr = env_list;
// 	while (curr)
// 	{
// 		if (curr->name)
// 			count++;
// 		curr = curr->next;
// 	}
// 	return (count);
// }

// static char	*create_env_entry_str(t_env *node)
// {
// 	char	*entry;
// 	char	*tmp;

// 	if (node->value != NULL)
// 	{
// 		tmp = ft_strjoin(node->name, "=");
// 		if (!tmp)
// 			return (NULL);
// 		entry = ft_strjoin(tmp, node->value);
// 		free(tmp);
// 	}
// 	else
// 		entry = ft_strdup(node->name);
// 	return (entry);
// }

// static int	fill_env_array(char **arr, t_env *env_list, int count)
// {
// 	t_env	*curr;
// 	int		i;

// 	curr = env_list;
// 	i = 0;
// 	while (curr && i < count)
// 	{
// 		if (curr->name)
// 		{
// 			arr[i] = create_env_entry_str(curr);
// 			if (!arr[i])
// 			{
// 				free_arr(arr);
// 				return (0);
// 			}
// 			i++;
// 		}
// 		curr = curr->next;
// 	}
// 	arr[i] = NULL;
// 	return (1);
// }

// char	**ft_list_to_array(t_env *env_list)
// {
// 	int		count;
// 	char	**arr;

// 	count = count_env_nodes(env_list);
// 	arr = malloc(sizeof(char *) * (count + 1));
// 	if (!arr)
// 	{
// 		perror("minishell: export: malloc failed in list_to_array");
// 		return (NULL);
// 	}
// 	if (!fill_env_array(arr, env_list, count))
// 		return (NULL);
// 	return (arr);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cd_built_in_utils.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/04 14:21:27 by ymazini           #+#    #+#             */
/*   Updated: 2025/05/04 21:14:12 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../exec_header.h"

int	process_dir_change(char *target, t_data *data, int print_path_flag)
{
	char	*current_pwd;
	int		chdir_ret;

	current_pwd = getcwd(NULL, 0);
	if (!current_pwd)
	{
		perror("minishell: cd: error retrieving current directory");
		data->last_exit_status = EXIT_FAILURE;
		return (EXIT_FAILURE);
	}
	chdir_ret = chdir(target);
	if (chdir_ret == -1)
		return (cd_error(target, data, current_pwd));
	if (print_path_flag)
		ft_putendl_fd(target, STDOUT_FILENO);
	if (update_pwd_env_vars(data, current_pwd) == -1)
	{
		free(current_pwd);
		data->last_exit_status = EXIT_FAILURE;
		return (EXIT_FAILURE);
	}
	free(current_pwd);
	data->last_exit_status = EXIT_SUCCESS;
	return (EXIT_SUCCESS);
}

int	cd_error(char *path, t_data *data, char *old_pwd_to_free)
{
	ft_putstr_fd("minishell: cd: ", STDERR_FILENO);
	ft_putstr_fd(path, STDERR_FILENO);
	ft_putstr_fd(": ", STDERR_FILENO);
	ft_putendl_fd(strerror(errno), STDERR_FILENO);
	free(old_pwd_to_free);
	data->last_exit_status = EXIT_FAILURE;
	return (EXIT_FAILURE);
}

static int	update_existing_env_node(t_env *node, const char *value)
{
	free(node->value);
	node->value = NULL;
	if (value)
	{
		node->value = ft_strdup(value);
		if (!node->value)
			return (-1);
	}
	return (0);
}

static int	add_new_env_node(t_env **list_head, t_env *last_node,
							const char *name, const char *value)
{
	char	*new_name;
	char	*new_value;
	t_env	*new_node;

	new_name = ft_strdup(name);
	if (!new_name)
		return (-1);
	new_value = NULL;
	if (value)
	{
		new_value = ft_strdup(value);
		if (!new_value)
			return (free(new_name), -1);
	}
	new_node = ft_tenv_new(new_name, new_value, 0);
	if (!new_node)
		return (free(new_name), free(new_value), -1);
	if (last_node)
		last_node->next = new_node;
	else
		*list_head = new_node;
	return (0);
}

int	ft_list_setenv(t_env **env_list_head, const char *name, const char *value)
{
	t_env	*curr;
	t_env	*last;
	size_t	name_len;

	curr = *env_list_head;
	last = NULL;
	name_len = ft_strlen(name);
	while (curr)
	{
		if (curr->name && ft_strncmp(curr->name, name, name_len + 1) == 0)
			return (update_existing_env_node(curr, value));
		last = curr;
		curr = curr->next;
	}
	return (add_new_env_node(env_list_head, last, name, value));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cd_built_in_utils2.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ymazini <ymazini@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/04 21:14:43 by ymazini           #+#    #+#             */
/*   Updated: 2025/05/05 11:55:34 by ymazini          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../exec_header.h"

char	*expand_tilde_path(const char *path_arg, t_env *env_list)
{
	char	*home_dir;
	char	*expanded_path;

	if (!path_arg)
		return (NULL);
	if (path_arg[0] != '~')
		return (ft_strdup(path_arg));
	home_dir = ft_list_getenv(env_list, "HOME");
	if (!home_dir || home_dir[0] == '\0')
		return (NULL);
	if (path_arg[1] == '\0')
		return (ft_strdup(home_dir));
	if (path_arg[1] == '/')
	{
		expanded_path = ft_strjoin(home_dir, path_arg + 1);
		if (!expanded_path)
			perror("minishell: cd: malloc failed");
		return (expanded_path);
	}
	else
		return (ft_strdup(path_arg));
}

char	*ft_list_getenv(t_env *env_list, const char *name)
{
	t_env	*curr;
	size_t	name_len;

	if (!env_list || !name)
		return (NULL);
	curr = env_list;
	name_len = ft_strlen(name);
	while (curr)
	{
		if (curr->name && ft_strncmp(curr->name, name, name_len + 1) == 0)
			return (curr->value);
		curr = curr->next;
	}
	return (NULL);
}
